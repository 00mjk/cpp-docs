---
title: "Return Value Optimizations"
ms.date: "12/10/2019"
description: "The named return value optimization (NRVO) in the Microsoft C++ compiler eliminates redundant copy constructor and destructor calls in various situations."
helpviewer_keywords: ["NRVO [C++]", "Named return value optimization [C++]"]
---

# Named Return Value Optimization

One of the most important ways to optimize a C++ program for speed is to avoid making unnecessary copies of objects. In un-optimized code, which includes all code generated by older compilers, a common source of unnecessary copy operations was when an object was declared on the stack inside a function body (as a *local variable*) and then returned to the caller. The following example

Consider what steps are required in a program, if no optimizations are enabled, when a function declares a local class variable on the stack and returns it to a caller:

- construct the variable at the call site that will be assigned the returned object (line 12)
- construct the local variable inside `f` (line 5)
- copy the local variable and assign it to the variable constructed at the call site (lines 7 and 13)
- invoke the destructor for goes out of scope

The C++ standard allows the elision of the copy constructor (even if this results in different program behavior).  which has a side effect of enabling the compiler to treat both objects as one (see section 12.8. Copying class objects, paragraph 15; see Reference*).* The Visual C++ 8.0 compiler makes use of the flexibility that the standard provides and adds a new feature: Named Return Value Optimization (NRVO). NRVO eliminates the copy constructor and destructor of a stack-based return value. This optimizes out the redundant copy constructor and destructor calls and thus improves overall performance. It is to be noted that this could lead to different behavior between optimized and non-optimized programs (see the Optimization Side Effects section).

There are some cases in which the optimization will not take place (see the Optimization Limitations section for samples). The more common ones are:

- Different paths returning different named objects.
- Multiple return paths (even if the same named object is returned on all paths) with EH states introduced.
- The named object returned is referenced in an inline asm block.

## Simple example

Here is a simple example to illustrate the optimization and how it is implemented:

```cpp
A MyFunction (B &var)
{
   A retVal;
   retVal.member = var.value + bar(var);
   return retVal;
}
```

The program that uses the above function may have a construct such as:

```cpp
valA = MyFunction(valB);
```

## Hidden code without NRVO

That value that is returned from MyFunction is created in the memory space pointed to by ValA through the use of hidden argument. Here is what the function looks like in pseudo-code when we expose the hidden argument and explicitly show the constructors and destructors:

```cpp
A MyFunction (A &_hiddenArg, B &var)
{
   A retVal;
   retVal.A::A(); // constructor for retVal
   retVal.member = var.value + bar(var);
   _hiddenArg.A::A(retVal);  // the copy constructor for A
   return;
retVal.A::~A();  // destructor for retVal

}
```

## Hidden code with NRVO

From the above code, it is noticeable that there are some optimization opportunities available. The basic idea is to eliminate the temporary stack-based value (retVal) and use the hidden argument. Consequently, this will eliminate the copy constructor and destructor of the stack-based value. Here is the NRVO-based optimized code:

```cpp
A MyFunction(A &_hiddenArg, B &var)
{
   _hiddenArg.A::A();
   _hiddenArg.member = var.value + bar(var);
   Return
}
```

## Example 1: Simple NRVO demonstration

The following example demonstrates NRVO in action by outputting a message whenever the constructor, copy constructor and destructor are invoked:

```cpp
#include <stdio.h>
class RVO
{
public:

   RVO(){printf("I am in constructor\n");}
   RVO (const RVO& c_RVO) {printf ("I am in copy constructor\n");}
   ~RVO(){printf ("I am in destructor\n");}
   int mem_var;
};

RVO MyFunction (int i)
{
   RVO rvo;
   rvo.mem_var = i;
   return (rvo);
}

int main()
{
   RVO rvo;
   rvo=MyFunction(5);
}
```

Compiling and running Example 1 with and without NRVO turned on will yield different behavior. In a debug build, NRVO is disabled by default with the [/Od](../build/reference/o-options-optimize-code.md) option, so the program prints:

```output
I am in constructor
I am in constructor
I am in copy constructor
I am in destructor
I am in destructor
I am in destructor
```

In a Release build, NRVO is enabled by default with the [/O2](../build/reference/o1-o2-minimize-size-maximize-speed.md) option, so the program prints:

```output
I am in constructor
I am in constructor
I am in destructor
I am in destructor
```

## Example 2: Complex NRVO demonstration

The following example is more complex:

```cpp
#include <stdio.h>
class A {
  public:
   A() {printf ("A: I am in constructor\n");i = 1;}
   ~A() { printf ("A: I am in destructor\n"); i = 0;}
   A(const A& a) {printf ("A: I am in copy constructor\n"); i = a.i;}
   int i, x, w;
};

class B {
  public:
   A a;
   B()  { printf ("B: I am in constructor\n");}
   ~B() { printf ("B: I am in destructor\n");}
   B(const B& b) { printf ("B: I am in copy constructor\n");}
};

A MyFunction()
{
   B* b = new B();
   A a = b->a;
   delete b;
   return (a);
}

int main()
{
   A a;
   a = MyFunction();
}
```

The output in a Debug build without NRVO will look like this:

```output
A: I am in constructor
A: I am in constructor
B: I am in constructor
A: I am in copy constructor
B: I am in destructor
A: I am in destructor
A: I am in copy constructor
A: I am in destructor
A: I am in destructor
A: I am in destructor
```

In a Release build, the NRVO optimization is enabled, so the output will be:

```output
A: I am in constructor
A: I am in constructor
B: I am in constructor
A: I am in copy constructor
B: I am in destructor
A: I am in destructor
A: I am in destructor
A: I am in destructor
```

## Example 3: Optimization Limitations

There are some cases where the optimization won't actually kick in. Here are few samples of such limitations.

In the face of exceptions the hidden argument must be destructed within the scope of the temporary that it is replacing. To illustrate:

```cpp
//RVO class is defined in previous example
#include <stdio.h>
RVO MyFunction (int i)
{
   RVO rvo;
   rvo.mem_var = i;
   throw "I am throwing an exception!";
   return (rvo);
}

int main()
{
   RVO rvo;
   try
   {
      rvo=MyFunction(5);
   }
   catch (const char* str)
   {
      printf ("I caught the exception\n");
   }
}
```

Without NRVO, the program outputs:

```output
I am in constructor
I am in constructor
I am in destructor
I caught the exception
I am in destructor
```

If the **throw** is commented out, the output is:

```output
I am in constructor
I am in constructor
I am in copy constructor
I am in destructor
I am in destructor
I am in destructor
```

If NRVO is enabled, and the **throw** is not commented out, the output is:

```output
I am in constructor
I am in constructor
I am in destructor
I caught the exception
I am in destructor
```

In other words, Example 3 behaves the same with and without NRVO.

## Example 4: Different named object sample

To make use of NRVO, all exit paths must return the same named object. To illustrate, consider the following example:

```cpp
#include <stdio.h>
class RVO
{
public:

   RVO(){printf("I am in constructor\n");}
   RVO (const RVO& c_RVO) {printf ("I am in copy constructor\n");}
   int mem_var;
};

RVO MyFunction (int i)
{
   RVO rvo;
   rvo.mem_var = i;
     if (rvo.mem_var == 10)
       return (RVO());
   return (rvo);
}

int main()
{
   RVO rvo;
   rvo=MyFunction(5);
}
```

The output while optimizations are enabled is the same as not enabling any optimizations. The NRVO doesn't actually take place because not all return paths return the same named object.

```output
I am in constructor
I am in constructor
I am in copy constructor
```

The following example modifies the previous one so that all exit paths return `rvo`. This change enables the optimization to eliminate the copy constructor:

```cpp
#include <stdio.h>
class RVO
{
public:

   RVO(){printf("I am in constructor\n");}
   RVO (const RVO& c_RVO) {printf ("I am in copy constructor\n");}
   int mem_var;
};

RVO MyFunction (int i)
{
   RVO rvo;
   if (i==10)
       return (rvo);
   rvo.mem_var = i;
   return (rvo);
}

int main()
{
   RVO rvo;
   rvo=MyFunction(5);
}
```

The output with NRVO enabled is now like this:

```output
I am in constructor
I am in constructor
```

## Example 5: EH Restriction Sample

The following example is the same as Example 4, with the addition of a destructor to the `RVO` class. Having multiple return paths and introducing such a destructor creates EH states in the function. The compiler avoids the return value optimization due to the complexity of the code paths in this scenario.

```cpp
//RVO class is defined above in figure 4
#include <stdio.h>
RVO MyFunction (int i)
{
   RVO rvo;
   if (i==10)
      return (rvo);
   rvo.mem_var = i;
   return (rvo);
}

int main()
{
   RVO rvo;
   rvo=MyFunction(5);
}
```

Compiling and running the example with and without optimization will yield the same result:

```output
I am in constructor
I am in constructor
I am in copy constructor
I am in destructor
I am in destructor
I am in destructor
```

To make use of NRVO, try to eliminate the multiple return points in such cases by changing MyFunction to be something like:

```cpp
RVO MyFunction (int i)
{
   RVO rvo;
   if (i!=10)
      rvo.mem_var = i;
   return(rvo);
}
```

## Example 6: Inline asm restriction

Another case where the compiler avoids performing NRVO is when the named return object is referenced in an inline asm block. To illustrate, consider the sample below:

```cpp
#include <stdio.h>
//RVO class is defined above in figure 4
RVO MyFunction (int i)
{
   RVO rvo;
__asm {
        mov eax,rvo   //comment this line out for RVO to kick in
        mov rvo,eax //comment this line out for RVO to kick in
     }
   return (rvo);
}
int main()
{
   RVO rvo;
   rvo=MyFunction(5);
}
```

Compiling and running the example with NRVO enabled does not take advantage of NRVO. That is because the object returned was actually referenced in an inline asm block. Therefore, the output with and without optimizations will look the same:

```output
I am in constructor
I am in constructor
I am in copy constructor
I am in destructor
I am in destructor
I am in destructor
```

From the output, it is clear that the elimination of the copy constructor and destructor calls did not take place. If the asm block gets commented out, such calls will get eliminated.

## Optimization Side Effects

You should be aware that the NRVO optimization can affect the flow of the application. The following example illustrates such a side effect:

```cpp
#include <stdio.h>
int NumConsCalls=0;
int NumCpyConsCalls=0;
class RVO
{
public:

   RVO(){NumConsCalls++;}
   RVO (const RVO& c_RVO) {NumCpyConsCalls++;}
};
RVO MyFunction ()
{
   RVO rvo;
   return (rvo);
}
void main()
{
   RVO rvo;
   rvo=MyFunction();
   int Division = NumConsCalls / NumCpyConsCalls;
   printf ("Constructor calls / Copy constructor calls = %d\n",Division);
}
```

Compiling and running the example with NRVO disabled (/Od) will yield what you should expect. The constructor is called twice and the copy constructor is called once. Therefore, the division (2/1) yields 2.

```output
Constructor calls / Copy constructor calls = 2
```

On the other hand, if the above code is compiled with optimization enabled (/O2), NRVO will eliminate the copy constructor call. As a result, `NumCpyConsCalls` will be zero, leading to a division by zero exception, which if not handled might cause the application to crash.
