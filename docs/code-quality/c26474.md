---
title: C26474
ms.date: 11/15/2017
ms.topic: "conceptual"
f1_keywords: ["C26474"]
helpviewer_keywords: ["C26474"]
ms.assetid: 1e23a8e6-97fa-47f5-a279-b52aa2efafa4

---
# C26474 NO_IMPLICIT_CAST

"Don't cast between pointer types when the conversion could be implicit."

**C++ Core Guidelines**:
Type.1: Avoid casts

In some cases, implicit casts between pointer types can safely be done and donâ€™t require user to write specific cast expression. This rule finds instances of such unnecessary casting which can be removed.

## Remarks

- The rule ID is a bit misleading: it should be interpreted as "implicit cast is not used where it is acceptable".
  - The rule is applicable to pointers only and checks static casts and reinterpret casts.
  - The following cases are acceptable pointer conversions that should not use explicit cast expressions:
    - conversion to nullptr_t;
    - conversion to void*;
    - conversion from a derived type to its base when invoking a base member function that is not hidden by the derived type. 

## Example 1

unnecessary conversion hides logic error

```cpp
template<class T>
bool register_buffer(T buffer) {
    auto p = reinterpret_cast<void*>(buffer); // C26474, also 26490 NO_REINTERPRET_CAST
    return buffers_.insert(p).second;
}

void merge_bytes(std::uint8_t *left, std::uint8_t *right)
{
    if (left && register_buffer(*left)) { // Unintended dereference!
        // ...
        if (right && register_buffer(right)) {
            // ...
        }
    }
}
```

unnecessary conversion hides logic error - reworked

```cpp
// ...
template<class T>
bool register_buffer(T *buffer) {
    auto p = buffer;
    return buffers_.insert(p).second;
}
// ...
```

## Example 2
Using casts to access base-class member functions
```cpp
struct struct_1
{
  void foo();
  void bar();
};
struct struct_2 : struct_1
{
  void foo(); // this definition hides struct_1::foo
};

void fn(struct_2* ps2)
{
  static_cast<struct_1*>(ps2)->foo(); // this cast is necessary to access `struct_1::foo`
                                      // alternatively ps2->struct_1::foo();
  static_cast<struct_1*>(ps2)->bar(); // this cast is unnecessary and can be done implicitly
}
```
