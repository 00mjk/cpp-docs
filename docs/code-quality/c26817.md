---
title: C26817
ms.date: 02/24/2020
ms.topic: "reference"
f1_keywords: ["C26817"]
helpviewer_keywords: ["C26817"]
ms.assetid: ???
---
# C26817
> Potentially expensive copy of variable *%var%* in range-for loop. Consider making it a const reference (es.71).

See [ES.71 notes](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#note-217)

## Example

If a range-for loop variable is not explicitly marked as a reference, it takes a copy of each element being iterated:

```
class MyComplexType {...};
...
for (auto it: vector<MyComplexType>) { // at each iteration of the loop, `it` takes a copy of the next element in the iteration
  ...
}
for (MyComplexType it: vector<MyComplexType>) { // this happens irrespective of using the `auto` keyword
  ...
}
```

This is fine for scalars (pointers, arithmetic types, ...), but for larger types, the copying may become expensive.

## Fix

To fix this issue, if the loop variable is not being mutated anywhere in the loop, it may be marked as a const reference:

```
class MyComplexType {...};
...
for (const auto& it: vector<MyComplexType>) { // no longer any copying
  ... loop variable not mutated in the loop body ...
}
for (const MyComplexType& it: vector<MyComplexType>) { // no longer any copying
  ... loop variable not mutated in the loop body ...
}
```

Otherwise, if the loop variable is being mutated, marking it as a reference will cause potentially unwanted side effects onto the original elements in the container. In this case, the potentially expensive copying is unavoidable.
